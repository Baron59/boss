/*	Better Oblivion Sorting Software
	
	Quick and Dirty Load Order Utility
	(Making C++ look like the scripting language it isn't.)

    Copyright (C) 2009-2010  Random/Random007/jpearce & the BOSS development team
    http://creativecommons.org/licenses/by-nc-nd/3.0/

	$Revision: 1437 $, $Date: 2010-08-31 22:22:32 +0100 (Tue, 31 Aug 2010) $
*/

#include "Userlist.h"

namespace boss {

using namespace std;
namespace fs = boost::filesystem;

//Checks if a given object is an esp, an esm or a ghosted mod.
bool IsPlugin(string object) {
	return (object.find(".esp")!=string::npos || object.find(".esm")!=string::npos || object.find(".ghost")!=string::npos);
}


//Debug function, just prints the object contents to the output file stream given.
void Rules::PrintRules(ofstream& output) {
	output << "Rule dump commencing..." << "<br />" << endl;
	for (int i=0;i<(int)objects.size();i++) {
		output << keys[i] << ": " << objects[i] << "<br />" << endl;
	}
	output << "Rule dump finished.";
}

//Prints messages generated by userlist parsing and rule processing to the output file stream given.
void Rules::PrintMessages(ofstream& output) {
	output << messages;
}

//Add rules from userlist.txt into the rules object.
//Then checks rule syntax and discards rules with incorrect structures.
//Also checks if the mods referenced by rules are in your Data folder, and discards rule that reference missing mods.
//Generates error messages for rules that are discarded.
void Rules::AddRules() {
	ifstream userlist;
	string line,key,object;
	int pos;
	bool skip = false;
	userlist.open("BOSS\\userlist.txt");
	messages += "<p>";
	while (!userlist.eof()) {
		char cbuffer[MAXLENGTH];
		userlist.getline(cbuffer,MAXLENGTH);
		line=cbuffer;
	//while(GetLine(userlist,line)) {
		if (line.length()>0) {
		if (line.substr(0,2)!="//") {
			pos = line.find(':');
			key = line.substr(0,pos);
			object = line.substr(pos+2);
			if (key=="ADD" || key=="OVERRIDE" || key=="FOR") {
				if (skip) {
					keys.erase(keys.begin()+rules.back(), keys.end());
					objects.erase(objects.begin()+rules.back(), objects.end());
					rules.pop_back();
				}
					keys.push_back(key);
					objects.push_back(object);
					rules.push_back((int)keys.size()-1);
					skip = false;
				if (IsPlugin(object) && !(fs::exists(object) || fs::exists(object+".ghost"))) {
					messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "\""+object+"\" is not installed.<br />";
					skip = true;
				}
				if (key=="ADD" && !IsPlugin(object)) {
					if (skip==false) messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "<span class='error'>It tries to add a group.</span><br />";
					skip = true;
				}
				if (!IsPlugin(object) && Tidy(object)=="esms" && key=="OVERRIDE") {
					if (skip==false) messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "<span class='error'>It tries to sort the group \"ESMs\".</span><br />";
					skip = true;
				}
				if ((Tidy(object)=="oblivion.esm" || Tidy(object)=="fallout3.esm" || Tidy(object)=="morrowind.esm") && key=="OVERRIDE") {
					if (skip==false) messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "<span class='error'>It tries to sort the master .ESM file.</span><br />";
					skip = true;
				}
			} else if ((key=="BEFORE" || key=="AFTER")) {
				keys.push_back(key);
				objects.push_back(object);
				if (IsPlugin(object) && !(fs::exists(object) || fs::exists(object+".ghost"))) {
					if (skip==false) messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "<span class='error'>\""+object+"\" is not installed.</span><br />";
					skip = true;
				}
				if ((IsPlugin(object) && !IsPlugin(objects[rules.back()])) || (!IsPlugin(object) && IsPlugin(objects[rules.back()]))) {
					if (skip==false) messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "<span class='error'>It references a mod and a group.</span><br />";
					skip = true;
				}
				if (keys[rules.back()]=="FOR") {
					if (skip==false) messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "<span class='error'>It includes a sort line in a rule with a FOR rule keyword.</span><br />";
					skip = true;
				}
				if (Tidy(object)=="esms" && key=="BEFORE") {
					if (skip==false) messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "<span class='error'>It tries to sort a group before the group \"ESMs\".</span><br />";
					skip = true;
				}
				if ((Tidy(object)=="oblivion.esm" || Tidy(object)=="fallout3.esm" || Tidy(object)=="morrowind.esm") && key=="BEFORE") {
					if (skip==false) messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "<span class='error'>It tries to sort a mod before the master .ESM file.</span><br />";
					skip = true;
				}
					
			} else if ((key=="APPEND" || key=="REPLACE")) {
				keys.push_back(key);
				objects.push_back(object);
				if (!IsPlugin(objects[rules.back()])) {
					if (skip==false) messages += "</p><p style='margin-left:40px; text-indent:-40px;'>The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" has been skipped as it has the following problem(s):<br />";
					messages += "<span class='error'>It tries to attach a message to a group.</span><br />";
					skip = true;
				}
			} else {			//Key not written correctly. Cannot tell if this was the start of a rule, or in the middle of a rule.
								//Therefore to prevent problems, skip the rule. If it is the start of a new rule, that rule and the previous rule will be skipped.
				messages += "</p><p><span class='error'>The line \""+key+": "+object+"\" has a keyword that was not recognised.<br />Make sure that you have spelt the keyword correctly and that it is written in block capitals.<br />";
				messages += "The rule beginning \""+keys[rules.back()]+": "+objects[rules.back()]+"\" will be skipped to prevent problems. If the line with the unrecognised keyword is the start of a new rule, that rule will also be skipped.</span><br />";
				skip = true;
			}
		}
	}
	}
	messages += "</p>";
	if (skip) {
		keys.erase(keys.begin()+rules.back(), keys.end());
					objects.erase(objects.begin()+rules.back(), objects.end());
		rules.pop_back();
	}
	userlist.close();
}

//Find the line in the keys/objects vectors that contains the given object.
int Rules::GetRuleIndex(string object, string key) {
	for (int i=0;i<(int)objects.size();i++) {
		if (Tidy(objects[i])==Tidy(object) && keys[i]==key) return i;
	}
	return -1;
}

}