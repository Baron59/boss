/*	Better Oblivion Sorting Software
	
	Quick and Dirty Load Order Utility
	(Making C++ look like the scripting language it isn't.)

    Copyright (C) 2009-2010  Random/Random007/jpearce & the BOSS development team
    http://creativecommons.org/licenses/by-nc-nd/3.0/

	$Revision: 1284 $, $Date: 2010-08-05 03:43:59 +0100 (Thu, 05 Aug 2010) $
*/

/*	This file is my playground for working on userlist implementation, though it's also got a WIP modlist class too
	that will hopefully take over from the current implementation soon too (it just needs to list files in date order now)
*/

#ifndef __BOSS_USERLIST_H__
#define __BOSS_USERLIST_H__

#include <string>
#include <fstream>
#include "Globals.h"
#include <Support/Types.h>
#include <Support/Helpers.h>
#include <vector>

#include "boost/filesystem.hpp"

namespace fs = boost::filesystem;

namespace boss {
	using namespace std;
	
	//Rules class contains storage objects for all 4 parts of a rule.
	//Also contains constructor-ish function to load all rules.
	//And a few other useful functions.
	class Rules {
	public:
		vector<string> l1obj,l2obj,objectcontent,l1key,l2key;
		string messages;
		void AddRules();
		void PrintRules(ofstream& output);
		void PrintMessages(ofstream& output);
		bool IsValidMessageRule(int i);
		bool IsValidSortRule(int i);
		bool IsModSortRule(int i);
	};

	//Debug function, just prints the object contents to the output file stream given.
	void Rules::PrintRules(ofstream& output) {
		output << "Rule dump commencing..." << endl << endl;
		for (int i=0;i<(int)l1obj.size();i++) {
			output << l1key[i] << ": " << l1obj[i] << endl
					<< l2key[i] << ": " << l2obj[i] << endl << endl;
		}
		output << "Rule dump finished.";
	}

	//Prints messages generated by userlist parsing and rule processing to the output file stream given.
	void Rules::PrintMessages(ofstream& output) {
		output << messages;
	}

	//Add rules from userlist.txt into the rules object.
	//Then checks rule syntax and discards rules with incorrect structures.
	//Also checks if the mods referenced by rules are in your Data folder, and discards rule that reference missing mods.
	//Generates error messages for rules that are discarded.
	void Rules::AddRules() {
		ifstream userlist;
		string line,key,object;
		int pos;
		userlist.open("BOSS\\userlist.txt");
		while(GetLine(userlist,line)) {
			if (line.substr(0,2)!="//") {
				pos = line.find(':');
				key = line.substr(0,pos);
				object = line.substr(pos+2);
				if (key=="APPEND" || key=="REPLACE" || key=="ADD" || key=="OVERRIDE") {
					l1obj.push_back(object);
					l1key.push_back(key);
				} else if (key=="BEFORE" || key=="AFTER" || key=="FOR") {
					l2obj.push_back(object);
					l2key.push_back(key);
				}
			}
		}
		userlist.close();
		objectcontent.resize(l1obj.size());
		vector<int> indicies;
		for (int i=0;i<(int)l1obj.size();i++) {
			if (!IsValidMessageRule(i) && !IsValidSortRule(i)) {
				indicies.push_back(i);
				messages += "The rule beginning \""+l1key[i]+": "+l1obj[i]+"\" does not have the correct syntax. Rule application skipped.\n";
			} else if (IsModSortRule(i) && (!FileExists(l1obj[i]) || !FileExists(l2obj[i]))) {
				indicies.push_back(i);
				messages += "The rule beginning \""+l1key[i]+": "+l1obj[i]+"\" references one or more mods that are not present in your Data folder. Rule application skipped.\n";
			} else if (IsValidMessageRule(i) && (!FileExists(l2obj[i]))) { 
				indicies.push_back(i);
				messages += "The rule beginning \""+l1key[i]+": "+l1obj[i]+"\" references a mod that is not present in your Data folder. Rule application skipped.\n";
			}
		}
		for (int i=0;i<(int)indicies.size();i++) {
			l1obj.erase(l1obj.begin()+indicies[i]-i);
			l2obj.erase(l2obj.begin()+indicies[i]-i);
			objectcontent.erase(objectcontent.begin()+indicies[i]-i);
			l1key.erase(l1key.begin()+indicies[i]-i);
			l2key.erase(l2key.begin()+indicies[i]-i);
		}
	}

	//Checks if the ith rule is a valid message rule.
	bool Rules::IsValidMessageRule(int i) {
		return ((l1key[i]=="APPEND" || l1key[i]=="REPLACE") && l2key[i]=="FOR" && (l2obj[i].find(".esp")!=string::npos || l2obj[i].find(".esm")!=string::npos) && l1obj[i].length()>1);
	}

	//Checks if the ith rule is a valid sorting rule.
	bool Rules::IsValidSortRule(int i) {
		return ((l1key[i]=="ADD" || l1key[i]=="OVERRIDE") && (l2key[i]=="BEFORE" || l2key[i]=="AFTER") && (((l2obj[i].find(".esp")!=string::npos || l2obj[i].find(".esm")!=string::npos) && (l1obj[i].find(".esp")!=string::npos || l1obj[i].find(".esm")!=string::npos)) || (l2obj[i].find(".esp")==string::npos && l2obj[i].find(".esm")==string::npos && l1obj[i].find(".esp")==string::npos && l1obj[i].find(".esm")==string::npos)));
	}

	//Checks if the sort rule sorts mods or not. If not, it sorts groups (obviously).
	bool Rules::IsModSortRule(int i) {
		return ((l2obj[i].find(".esp")!=string::npos || l2obj[i].find(".esm")!=string::npos) && (l1obj[i].find(".esp")!=string::npos || l1obj[i].find(".esm")!=string::npos));
	}

	//Class to replace current modlist implementation.
	class Mods {
	public:
		vector<string> mods;
		void AddMods();
		void PrintModList(ofstream& out);
		void SaveModList();
	};

	//Adds mods in directory to Modlist.
	//Doesn't list them in date order yet.
	void Mods::AddMods() {
		fs::path p(".");
		if (fs::is_directory(p)) {
			for (fs::directory_iterator itr(p); itr!=fs::directory_iterator(); ++itr) {
				if (fs::is_regular_file(itr->status()) && (fs::extension(itr->filename())==".esp" || fs::extension(itr->filename())==".esm")) {
					mods.push_back(itr->filename());
				}
			}
		}
	}

	//Save mod list to modlist.txt.
	//Backs up old modlist.txt as modlist.old first.
	void Mods::SaveModList() {
		ofstream modlist;
		if (fs::exists("BOSS\\modlist.old")) fs::remove("BOSS\\modlist.old");
		if (fs::exists("BOSS\\modlist.txt")) fs::rename("BOSS\\modlist.txt", "BOSS\\modlist.old");
		modlist.open("BOSS\\modlist.txt");
		for (int i=0;i<(int)mods.size();i++) {
			modlist << mods[i] << endl;
		}
		//system ("dir *.es? /a:-d /b /o:d /t:w > BOSS\\modlist.txt");
	}

	//Debug output function.
	void Mods::PrintModList(ofstream& out) {
		for (int i=0;i<(int)mods.size();i++) {
			out << mods[i] << endl;
		}
	}

}

#endif __BOSS_USERLIST_H__