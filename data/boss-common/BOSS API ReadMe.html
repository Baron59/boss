<!DOCTYPE html>
<meta charset="utf-8">
<title>BOSS API ReadMe</title>
<style>
	body {font-family:Calibri,Arial,Verdana,sans-serifs;}
	body > div:first-child {font-size:2.4em; font-weight:bold; text-align:center; margin-bottom:0.2em;}
	body > div {margin-bottom:5em;}
	ol li, ul li {margin-bottom:10px;}
	li ul, li ol {margin-top:0.4em;}
	.codebox, .quotebox, .logbox {margin-left:40px; border:gray 1px dashed; display:table; min-width:300px; padding:5px 30px 5px 10px;}
	.codebox { font-family:monospace; background:#F5F5F5; line-height:20px; white-space:pre;}
	.quotebox {background:#E6E6FA;}
	.logbox {background:#E0FFFF; line-height:30px;}
	.logbox > ul > li {line-height:20px;}
	q {font-style:italic;}
	code {display:inline-box; padding:2px 5px; background:#EEEEEE;}
	td {border:1px solid #ccc; padding: 5px;}
	table {border:1px solid #CCCCCC; border-spacing:0; border-collapse:separate; margin:1em;}
	thead > tr td {font-weight:bold}
</style>

<div>Better Oblivion Sorting Software<br />
API Documentation</div>
<div><h1>Contents</h1>
<ol>
	<li><a href="#intro">Introduction</a>
	<li><a href="#overview">Background Information</a>
	<li><a href="#types">Variable Types</a>
	<li><a href="#codes">Return Codes</a>
	<li><a href="#functions">Functions</a>
	<ol style="list-style:lower-alpha;">
		<li><a href="#functions-version">Version Functions</a>
		<li><a href="#functions-lifecycle">Lifecycle Management Functions</a>
		<li><a href="#functions-loading">Database Loading Functions</a>
		<li><a href="#functions-access">Database Access Functions</a>
	</ol>
	<li><a href="#examples">Examples</a>
	<ol style="list-style:lower-alpha;">
		<li><a href="#examples-python">Python</a>
	</ol>
	<li><a href="#contact">Contact</a>
	<li><a href="#contact">Credits</a>
	<li><a href="#license">License</a>
	<li><a href="#history">Version History</a>
</ol>
</div>

<div id="intro"><h1>Introduction</h1>
<p>This documentation details the BOSS API and is intended for use by third party developers of modding utilities for TES IV: Oblivion, TES V: Skyrim, Nehrim - At Fate's Edge, Fallout 3 and Fallout: New Vegas.

<p>The BOSS API has a C frontend and is available as a 32-bit DLL that can be loaded by other modding utilities so that they can easily take advantage of the information stored within BOSS's files without having to write their own interfaces and keep such interfaces up-to-date as BOSS evolves.
</div>

<div id="overview"><h1>Overview</h1>
<p>The BOSS API allows third parties to extract information from BOSS's masterlist and userlist using the same parsers that BOSS itself uses, thereby minimising the effort required and increasing compatibility. The API currently has the following capabilities:
<ul>
	<li>Extract Bash Tag addition and removal suggestions for mods from the masterlist and userlist.
	<li>Extract dirty mod messages from the masterlist and determine cleanliness of mods.
	<li>Write a minimal masterlist containing only mods with Bash Tag suggestions, and those suggestions.
</ul>
<p>The API can also handle determining compatibility with other versions of BOSS that may be present. The API currently has a few shortcomings over a general file read, owing to the fact that it parses the lists in the same manner that BOSS itself does:
<ul>
	<li>Conditional information is only accessible if the condition	is fulfilled. This means that when the user's installed mod list changes, the database will have to be reloaded.
	<li>Database loading is very slow.
</ul>
<p>These shortcomings will be addressed in updates to the API, either in pre-release or in future releases.
<p>Below is a short overview of BOSS's masterlist, userlist and their capabilities for those unfamiliar with them:
<p>The masterlist is the file which holds the load order of all BOSS's recognised plugins. There is a separate masterlist for each game that BOSS supports, but since it only ever works on one game at a time, only one masterlist is generally ever referred to at any one time. The masterlist also holds messages to attach to plugins that BOSS displays in its BOSS Log output file, and these messages include general notes, Bash Tag suggestions (for addition and/or removal), requirements, incompatibilities, information regarding dirty edits, warnings and errors.
<p>The userlist is a file that BOSS users can use to override or add to BOSS's sorting and message display functionality using a specific rule syntax. The capabilities of these rules include overriding BOSS's ordering of individual plugins or groups of plugins, having BOSS sort plugins it would otherwise not recognise (ie. that are not in its masterlist) and adding or overriding plugin messages.
</div>

<div id="types"><h1>Variable Types</h1>
<p>The API uses character strings and integers for information input/output. 
<ul>
	<li>All API strings are unsigned 8-bit character strings (uint8_t*) encoded in UTF-8.
	<li>All API numbers and return codes are unsigned 32-bit integers (uint32_t).
</ul>
<p>The API also introduces two new structures:
<p><code>typedef struct _boss_db_int * boss_db;</code>
<p>Abstracts the definition of BOSS's internal state while still providing type safety across the API.

<p><pre><code>typedef struct {
    uint32_t id;
    const uint8_t * name;
} BashTag;</code></pre>
<p>The BashTag structure gives the Unique Identifier (UID) for each Bash Tag and the corresponding Bash Tag name.
</div>

<div id="codes"><h1>Return Codes</h1>
<p>The BOSS API functions uses the following uint32_t return codes to signal how a function completes.
<table>
	<thead><tr><td>Return Code<td>Description
	<tbody>
		<tr><td>BOSS_API_ERROR_OK<td>The function completed successfully.
		<tr><td>BOSS_API_ERROR_FILE_WRITE_FAIL<td>A file could not be written to.
		<tr><td>BOSS_API_ERROR_FILE_NOT_UTF8<td>The specified BOSS file (masterlist or userlist) is not encoded in UTF-8.
		<tr><td>BOSS_API_ERROR_FILE_NOT_FOUND<td>The specified file could not be found.
		<tr><td>BOSS_API_ERROR_PARSE_FAIL<td>There was an error parsing the file.
		<tr><td>BOSS_API_ERROR_NO_MEM<td>The API was unable to allocate the required memory.
		<tr><td>BOSS_API_ERROR_OVERWRITE_FAIL<td>The API was unable to overwrite the minimal masterlist specified.
		<tr><td>BOSS_API_ERROR_INVALID_ARGS<td>Invalid arguments were given for the function.
		<tr><td>BOSS_API_ERROR_MAX<td>Matches the value of the highest-numbered return code (BOSS_API_ERROR_INVALID_ARGS). It isn't returned by any functions.
</table>
</div>



<div id="functions"><h1>Functions</h1>
<p>BOSS API provides the functions listed below to clients. Where a function returns a uint32_t value, this is the function's return code.

<h2 id="functions-version">Version Functions</h2>

<p><code>bool <span style="color:blue;">IsCompatibleVersion</span> (uint32_t bossVersionMajor, uint32_t bossVersionMinor, uint32_t bossVersionPatch);</code>
<p>Returns whether this version of BOSS supports the API from the given BOSS version. Abstracts BOSS API stability policy away from clients.

<p><code>uint32_t <span style="color:blue;">GetVersionString</span> (const uint8_t ** bossVersionStr);</code>
<p>Returns the version string for this version of BOSS. The string exists for the lifetime of the library.

<h2 id="functions-lifecycle">Lifecycle Management Functions</h2>
<p><code>uint32_t <span style="color:blue;">CreateBossDb</span>  (boss_db * db);</code>
<p><code>void <span style="color:blue;">DestroyBossDb</span> (boss_db db);</code>
<p>Explicitly manage database lifetime. Allows clients to free memory when they want/need to.

<h2 id="functions-loading">Database Loading Functions</h2>

<p><code>uint32_t <span style="color:blue;">Load</span> (boss_db db, const uint8_t * masterlistPath, const uint8_t * userlistPath, const uint8_t * dataPath);</code>
<p>Loads the masterlist and userlist from the paths specified. Can be called multiple times. If an error is encountered, the database remains unchanged. Paths are case-sensitive if the underlying filesystem is case-sensitive. masterlistPath and userlistPath are files. dataPath is a directory. If userlistPath is an empty string, then the userlist is not loaded.

<p><code>uint32_t <span style="color:blue;">ReEvalRegex</span> (boss_db db, const uint8_t * dataPath);</code>
<p>Re-evaluates the masterlist's regex entries, so Load() doesn't need to be called whenever the mods installed are changed. This doesn't need to be used if Load() is called, as the evaluation is incorporated into Load() too. Paths are case-sensitive if the underlying filesystem is case-sensitive.


<h2 id="functions-access">Database Access Functions</h2>
<p><code>uint32_t <span style="color:blue;">GetBashTagMap</span> (boss_db db, BashTag ** tagMap, uint32_t * numTags);</code>
<p>Returns an array of the Bash Tags encounterred when loading the masterlist and userlist, and the number of tags in the returned array. The array and its contents are static and valid until the db is destroyed or until the Load() function is called. It should not be freed by the client.

<p><code>uint32_t <span style="color:blue;">GetModBashTags</span> (boss_db db, const uint8_t * modName, uint32_t ** tagIds_added, uint32_t * numTags_added, uint32_t **tagIds_removed, uint32_t *numTags_removed, bool * userlistModified);</code>
<p>Returns arrays of Bash Tag UIDs for Bash Tags suggested for addition and removal by BOSS's masterlist and userlist, and the number of tags in each array. The returned arrays are valid until GetModBashTags() is called again, the db is destroyed or the Load() function is called.  The arrays should not be freed by the client. modName is case-insensitive. If no Tags are found for an array, the array pointer (*tagIds) will be NULL. The userlistModified bool is true if the userlist contains Bash Tag suggestion message additions.



<p><code>uint32_t <span style="color:blue;">GetDirtyMessage</span> (boss_db db, const uint8_t * modName, const uint8_t ** message, uint32_t * needsCleaning);</code>
<p>Returns the message associated with a dirty mod and whether the mod needs cleaning. If a mod has no dirty message, *message will be NULL. modName is case-insensitive. The return values for needsCleaning are:
<table>
	<thead><tr><td>needsCleaning Value<td>Description
	<tbody>
		<tr><td>BOSS_API_CLEAN_NO<td>The plugin does not need cleaning or should not be cleaned.
		<tr><td>BOSS_API_CLEAN_YES<td>The plugin needs cleaning.
		<tr><td>BOSS_API_CLEAN_UNKNOWN<td>BOSS does not know whether the plugin needs cleaning or not, or if it should not be cleaned.
</table>
<p>The message string is valid until GetDirtyMessage() is called again, the db is destroyed or the Load() function is called. The string should not be freed by the client.

<p><code>uint32_t <span style="color:blue;">DumpMinimal</span> (boss_db db, const uint8_t * outputFile, const bool overwrite);</code>
<p>Writes a minimal masterlist that only contains mods that have Bash Tag suggestions, plus the Tag suggestions themselves, in order to create the Wrye Bash taglist. outputFile is the path to use for output. If outputFile already exists, it will only be overwritten if overwrite is true.
</div>

<div id="examples"><h1>Examples</h1>
<p>Below is a code snippet showing an example of how the BOSS API may be used.
<h2 id="examples-python">Python</h2>
<p style="font-style:italic;">This example was written by Lojack, with minor changes by WrinklyNinja.
<p>bapi.py
<div class="codebox"># -*- coding: utf-8 -*-

from ctypes import *
import os, platform

if '64bit' in platform.architecture():
    bapiPath = 'boss64.dll'
else:
    bapiPath = 'boss32.dll'

BAPI = None
if os.path.exists(bapiPath):
    try:
        BAPI = CDLL(bapiPath)
    except (AttributeError, ImportError, OSError), error:
        BAPI = None
        print error
    except:
        BAPI = None
        raise

if BAPI is not None:
    BOSS_API_ERROR_OK = c_uint.in_dll(BAPI, 'BOSS_API_ERROR_OK').value
    BOSS_API_ERROR_FILE_WRITE_FAIL = c_int.in_dll(BAPI, 'BOSS_API_ERROR_FILE_WRITE_FAIL').value
    BOSS_API_ERROR_FILE_NOT_UTF8 = c_int.in_dll(BAPI, 'BOSS_API_ERROR_FILE_NOT_UTF8').value
    BOSS_API_ERROR_FILE_NOT_FOUND = c_int.in_dll(BAPI, 'BOSS_API_ERROR_FILE_NOT_FOUND').value
    BOSS_API_ERROR_PARSE_FAIL = c_int.in_dll(BAPI, 'BOSS_API_ERROR_PARSE_FAIL').value
    BOSS_API_ERROR_NO_MEM = c_int.in_dll(BAPI, 'BOSS_API_ERROR_NO_MEM').value
    BOSS_API_ERROR_OVERWRITE_FAIL = c_int.in_dll(BAPI, 'BOSS_API_ERROR_OVERWRITE_FAIL').value
    BOSS_API_ERROR_INVALID_ARGS = c_int.in_dll(BAPI, 'BOSS_API_ERROR_INVALID_ARGS').value

    BOSS_API_CLEAN_NO  = 0
    BOSS_API_CLEAN_YES =  1
    BOSS_API_CLEAN_UNKNOWN = 2

    class BossError(Exception):
        err_str = {
            BOSS_API_ERROR_OK:'No error',
            BOSS_API_ERROR_FILE_WRITE_FAIL:'Exception while writing file',
            BOSS_API_ERROR_FILE_NOT_UTF8:'The file is not UTF8 encoded',
            BOSS_API_ERROR_FILE_NOT_FOUND:'The file does not exist',
            BOSS_API_ERROR_PARSE_FAIL:'Error occured while parsing',
            BOSS_API_ERROR_NO_MEM:'Out of memory',
            BOSS_API_ERROR_OVERWRITE_FAIL:'Overwrite fail',
            BOSS_API_ERROR_INVALID_ARGS:'Invalid arguments',
            }
        def __init__(self,value):
            self.value = value

        def __str__(self):
            return BossError.err_str.get(self.value,"Unknown")

        def __repr__(self): return 'BossError("'+self.__str__()+'")'

    def BossErrorCheck(result):
        if result != BOSS_API_ERROR_OK: raise BossError(result)
        return result

    # Some types
    boss_db = c_void_p
    boss_db_p = POINTER(boss_db)
    c_uint32_p = POINTER(c_uint32)
    c_uint32_p_p = POINTER(c_uint32_p)
    c_bool_p = POINTER(c_bool)
    c_char_p_p = POINTER(c_char_p)
    class BashTag(Structure):
        _fields_ = [('id',c_uint32),
                    ('name',c_char_p), # uint8_t *
                    ]
    BashTag_p = POINTER(BashTag)
    BashTag_p_p = POINTER(BashTag_p)

    ## bool IsCompatibleVersion(bossVersionMajor, bossVersionMinor, bossVersionPatch)
    _CIsCompatibleVersion = BAPI.IsCompatibleVersion
    _CIsCompatibleVersion.restype = c_bool
    _CIsCompatibleVersion.argtypes = [c_uint32, c_uint32, c_uint32]
    ## uint32_t GetVersionString(bossVersionStr)
    _CGetVersionString = BAPI.GetVersionString
    _CGetVersionString.restype = BossErrorCheck # uint32 (error code)
    _CGetVersionString.argtypes = [c_char_p_p] # uint8_t **
    ## uint32_t CreateBossDb(db)
    _CCreateBossDb = BAPI.CreateBossDb
    _CCreateBossDb.restype = BossErrorCheck
    _CCreateBossDb.argtypes = [boss_db_p]
    ## void DestroyBossDb(db)
    _CDestroyBossDb = BAPI.DestroyBossDb
    #_CDestroyBossDb.restype = void
    _CDestroyBossDb.argtypes = [boss_db]
    ## uint32_t Load(db, masterlistPath, userlistPath, dataPath)
    _CLoad = BAPI.Load
    _CLoad.restype = BossErrorCheck
    _CLoad.argtypes = [boss_db, c_char_p, c_char_p, c_char_p]
    ## uint32_t ReEvalRegex(boss_db db, const uint8_t *dataPath)
    _CReEvalRegex = BAPI.ReEvalRegex
    _CReEvalRegex.restype = BossErrorCheck
    _CReEvalRegex.argtypes = [boss_db, c_char_p]
    ## uint32_t GetBashTagMap(db, tabMap, numTags)
    _CGetBashTagMap = BAPI.GetBashTagMap
    _CGetBashTagMap.restype = BossErrorCheck
    _CGetBashTagMap.argtypes = [boss_db, BashTag_p_p, c_uint32_p]
    ## uint32_t GetModBashTags(db, modName, tagIds_added, numTags_added, tagIds_removed, numTags_removed, userlistModified
    _CGetModBashTags = BAPI.GetModBashTags
    _CGetModBashTags.restype = BossErrorCheck
    _CGetModBashTags.argtypes = [boss_db, c_char_p, c_uint32_p_p, c_uint32_p, c_uint32_p_p, c_uint32_p, c_bool_p]
    ## uint32_t GetDirtyMessage(db, modName, message, needsCleaning)
    _CGetDirtyMessage = BAPI.GetDirtyMessage
    _CGetDirtyMessage.restype = BossErrorCheck
    _CGetDirtyMessage.argtypes = [boss_db, c_char_p, c_char_p_p, c_uint32_p]
    ## uint32_t DumpMinimal(db, outputFile, overwrite)
    _CDumpMinimal = BAPI.DumpMinimal
    _CDumpMinimal.restype = BossErrorCheck
    _CDumpMinimal.argtypes = [boss_db, c_char_p, c_bool]

    version = c_char_p()
    try:
        _CGetVersionString(byref(version))
        version = unicode(version.value,'utf8')
    except BossError, e:
        print 'Error getting version:', e
        version = u'Error'

    def IsCompatibleVersion(majorVersion, minorVersion, patchVersion=0):
        return _CIsCompatibleVersion(majorVersion,minorVersion,patchVersion)

    class BossDB(object):
        def __init__(self):
            self.tags = {} # BashTag map
            self._DB = boss_db()
            _CCreateBossDb(byref(self._DB))

        def __del__(self):
            if self._DB is not None:
                _CDestroyBossDb(self._DB)
                self._DB = None

        # 'with' statement
        def __enter__(self): return self
        def __exit__(self, exc_type, exc_value, traceback): self.__del__()

        def Load(self, masterList, userList='', dataPath=''):
            """Loads a masterlist and userlist from specified paths.  Can be called
               multiple times.  On error, the database is unchanged.  Paths are case
               sensitive if the underlying filesystem is case sensitive."""
            # First load the files
            if isinstance(masterList, unicode): masterList = masterList.encode('utf8')
            if isinstance(userList, unicode):   userList = userList.encode('utf8')
            if isinstance(dataPath, unicode):   dataPath = dataPath.encode('utf8')
            _CLoad(self._DB, masterList, userList, dataPath)
            # Then retrieve the BashTag map
            num = c_uint32()
            bashTags = BashTag_p()
            _CGetBashTagMap(self._DB, byref(bashTags), byref(num))
            self.tags = {bashTags[i].id:unicode(bashTags[i].name,'utf8') for i in range(num.value)}

        def GetBashTags(self, modName):
            """Returns:
                 (added, removed, userlist)
               Where:
                 added = added tags
                 removed = removed tags
                 userlist = True if the userlist made modifications
            """
            if isinstance(modName, unicode): modName = modName.encode('utf8')
            # TODO: ReEvalRegex
            tagIds_added = c_uint32_p()
            numAdded = c_uint32()
            tagIds_removed = c_uint32_p()
            numRemoved = c_uint32()
            userlist = c_bool()
            _CGetModBashTags(self._DB,              # boss_db
                             modName,               # uint8_t *
                             byref(tagIds_added),   # uint32_t **
                             byref(numAdded),       # uint32_t *
                             byref(tagIds_removed), # uint32_t **
                             byref(numRemoved),     # uint32_t *
                             byref(userlist)        # bool *
                             )
            added = [self.tags[tagIds_added[x]] for x in range(numAdded.value)]
            removed = [self.tags[tagIds_removed[x]] for x in range(numRemoved.value)]
            return (added, removed, userlist.value)

        def GetDirtyMessage(self, modName):
            """Returns:
                 (cleaningMessage,shouldClean)
               Where:
                shouldClean = True if it should be cleaned
                shouldClean = False if it should not be cleaned
                shouldClean = None otherwise (unknown)
            """
            if isinstance(modName, unicode): modName = modName.encode('utf8')
            message = c_char_p()
            needsCleaning = c_uint32()
            _CGetDirtyMessage(self._DB,             # boss_db
                              modName,              # uint8_t *
                              byref(message),       # uint8_t **
                              byref(needsCleaning)  # bool *
                              )
            # NULL pointer returned if there is not cleaning message
            if message.value is None: message = u''
            #else: message = unicode(message,'utf8')
            return message,needsCleaning.value

        def DumpMinimal(self, fileName):
            if isinstance(fileName, unicode): fileName.encode('utf8')
            _CDumpMinimal(self._DB, fileName, True)
</div>
<p>bapi_test.py
<div class="codebox">import bapi
import os

def main():
    print 'BAPI version:', bapi.version
    print 'compatible with 1.8.0:', bapi.IsCompatibleVersion(1,8)

    with bapi.BossDB() as db:
        print 'loading lists...'
        root = os.getcwd()
        masterlist = os.path.join(root,'masterlist.txt')
        #userlist = os.path.join(root,'userlist.txt')
        userlist = ''
        db.Load(masterlist,userlist,root)
        print 'done loading.'
        print
        print db.tags
        print 'UOP:'
        print db.GetBashTags('Unofficial Oblivion Patch.esp')
        print db.GetDirtyMessage('Unofficial Oblivion Patch.esp')
        print 'Vanilla Weapon Stat Override:'
        print db.GetDirtyMessage('Vanilla Weapon Stat Override.esp')
        print 'Mehrunes Razor:'
        print db.GetDirtyMessage('DLCMehrunesRazor.esp')
        print
        print 'Non-existant:'
        print db.GetBashTags('dummy.esp')
        print db.GetDirtyMessage('dummy.esp')
        
        db.DumpMinimal('taglist.txt')
    print 'done destroying database.'

if __name__=='__main__':
    main()
</div>
</div>

<div id="contact"><h1>Contact</h1>
<p>The BOSS development team can be contacted by Private Messaging any of the handles given in the <q>Project Members</q> section of the main BOSS readme at the noted forums. 
<p>However, for API-specific support, it is best to contact WrinklyNinja (available on both the <a href="http://forums.bethsoft.com/index.php">Bethesda Softworks Forums</a> and <a href="http://www.thenexusforums.com/">The Nexus Forums</a>), who is currently responsible for all BOSS code development, including the API. Other team members are unlikely to be of any great assistance with coding-related queries.
<p>Developers can also request additional functionality, report any bugs encountered and discuss anything API-related in the <a href="http://forums.bethsoft.com/index.php?showtopic=1221990">offical BOSS API thread</a>. 
</div>

<div id="credits"><h1>Credits</h1>
<p>Credit goes to myk002 and Lojack for significant contributions to both coding and discussion from initial development through to beta testing. The BOSS API is written in C/C++ and makes use of the <a href="http://www.boost.org/">BOOST</a> and <a href="http://utfcpp.sourceforge.net/">UTF8-CPP</a> libraries.
</div>

<div id="license"><h1>License</h1>
<p>Please see the main BOSS readme for the full statement of BOSS's licensing: what follows is only an explanation of how that license applies to the API. As part of BOSS, the API is still licensed by the <a href="http://creativecommons.org/licenses/by-nc-nd/3.0">Creative Commons Attribution Noncommercial No Derivative Works 3.0 Unported</a> copyright license. This means that usage of it is restricted by the terms of the license, with the major (but not only) points being:
<ul>
	<li>As the API is distributed as part of the single BOSS archive or installer, it cannot be distributed by third parties separated from the rest of the BOSS files. If you wish to do so, you will need to ask for permission.
	<li>You cannot use the API in a commercial project (including advertising-supported) without permission.
	<li>As usage of the API constitutes a derivative work, you may not publish anything that uses it without first obtaining permission.
</ul>
<p>While the license is quite restrictive, its restrictions may be waived on a case-by-case basis if third party developers can provide strong arguments for doing so, and usage permission is almost guaranteed (but must still be obtained!) for non-commercial projects.
<p>The following third-party applications have been licensed to use the BOSS API at time of writing:
<ul>
	<li>Wrye Bash
</ul>
</div>

<div id="history"><h1>Version History</h1>
<p><b>Version 1.9</b> - <i>2011</i>
<ul>
	<li>Initial release.
</ul>
</div>